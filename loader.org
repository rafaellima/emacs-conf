#+TITLE: My GNU Emacs configuration
#+STARTUP: indent
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction

This is my version of an configuration file for GNU Emacs. I have been using GNU Emacs since 2015 when I was introduced to it by a colleague at Locaweb.

I modelled this set of files based off of the emacs-starter-kit at https://github.com/eschulte/emacs24-starter-kit.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Rafael Lima")
  (setq user-mail-address "rafa.cbl@gmail.com")
#+END_SRC


* A secure Emacs environment

Great article why [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Your editor is malware]]. The following basically sets up the configuration to adhere to the articles recommondations.

#+BEGIN_SRC shell :exports none
python -m pip install --user certifi
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;  (if (fboundp 'gnutls-available-p)
  ;;      (fmakunbound 'gnutls-available-p))

  (require 'cl)
  (setq tls-checktrust t)

  (setq python (or (executable-find "py.exe")
                   (executable-find "python")
                   ))

  (let ((trustfile
         (replace-regexp-in-string
          "\\\\" "/"
          (replace-regexp-in-string
           "\n" ""
           (shell-command-to-string (concat python " -m certifi"))))))
    (setq tls-program
          (list
           (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                   (if (eq window-system 'w32) ".exe" "") trustfile)))
    (setq gnutls-verify-error t)
    (setq gnutls-trustfiles (list trustfile)))

  ;; Test the settings by using the following code snippet:
  ;;  (let ((bad-hosts
  ;;         (loop for bad
  ;;               in `("https://wrong.host.badssl.com/"
  ;;                    "https://self-signed.badssl.com/")
  ;;               if (condition-case e
  ;;                      (url-retrieve
  ;;                       bad (lambda (retrieved) t))
  ;;                    (error nil))
  ;;               collect bad)))
  ;;    (if bad-hosts
  ;;        (error (format "tls misconfigured; retrieved %s ok" bad-hosts))
  ;;      (url-retrieve "https://badssl.com"
  ;;                    (lambda (retrieved) t))))
#+END_SRC

* Installing use-package
** Setup

GNU Emacs has a lot of packages that make things very easy for the
user. The package management infrastructure makes it a breeze to
install new packages and keep up-to-date with their development.

There are several package archives available for GNU Emacs:

- GNU
- Marmalade
- Melpa

Each archive will write its files in a seperate archive directory.

#+BEGIN_SRC emacs-lisp
  (require 'package)
#+END_SRC

Because the default setting for package-archives is to use the HTTP access to the GNU archive, I set the variable to `nil` before adding the HTTPS variants.

#+name: credmp-package-infrastructure
#+begin_src emacs-lisp

  (defvar gnu '("gnu" . "https://elpa.gnu.org/packages/"))
  (defvar melpa '("melpa" . "https://melpa.org/packages/"))
  (defvar melpa-stable '("melpa-stable" . "https://stable.melpa.org/packages/"))

  ;; Add marmalade to package repos
  (setq package-archives nil)
  (add-to-list 'package-archives melpa-stable t)
  (add-to-list 'package-archives melpa t)
  (add-to-list 'package-archives gnu t)
#+end_src

Initialize the archive and refresh the contents in case there is no cached archive.

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (unless (and (file-exists-p (concat init-dir "elpa/archives/gnu"))
               (file-exists-p (concat init-dir "elpa/archives/melpa"))
               (file-exists-p (concat init-dir "elpa/archives/melpa-stable")))
    (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing
packages will be installed. The packages-install function deals with
this check and takes care of any loading of the packages.

#+name: credmp-package-installer
#+begin_src emacs-lisp
  (defun packages-install (&rest packages)
    (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (when (not (package-installed-p name))
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+end_src

** The package

#+name: credmp-package-installer
#+begin_src emacs-lisp
  ;; Install extensions if they're missing
  (defun init--install-packages ()
    (message "Lets install some packages")
    (packages-install
     ;; Since use-package this is the only entry here
     ;; ALWAYS try to use use-package!
     (cons 'use-package melpa)
     ))

  (condition-case nil
      (init--install-packages)
    (error
     (package-refresh-contents)
     (init--install-packages)))
#+end_src

* Moving around

Be sure to just ask for y/n instead of yes/no.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Bookmarks are very useful for quickly jumping around files.

#+BEGIN_SRC emacs-lisp
  (use-package bm
    :ensure t
    :bind (("C-c =" . bm-toggle)
           ("C-c [" . bm-previous)
           ("C-c ]" . bm-next)))

#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-x" . counsel-M-x)
     ("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

   (use-package swiper
     :pin melpa-stable
     :diminish ivy-mode
     :ensure t
     :bind*
     (("C-s" . swiper)
      ("C-c C-r" . ivy-resume)
      ("C-x C-f" . counsel-find-file)
      ("C-c h f" . counsel-describe-function)
      ("C-c h v" . counsel-describe-variable)
      ("C-c i u" . counsel-unicode-char)
      ("M-i" . counsel-imenu)
      ("C-c g" . counsel-git)
      ("C-c j" . counsel-git-grep)
      ("C-c k" . counsel-ag)
      ("C-c l" . scounsel-locate))
     :config
     (progn
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (define-key read-expression-map (kbd "C-r") #'counsel-expression-history)
       (ivy-set-actions
	'counsel-find-file
	'(("d" (lambda (x) (delete-file (expand-file-name x)))
           "delete"
           )))
       (ivy-set-actions
	'ivy-switch-buffer
	'(("k"
           (lambda (x)
             (kill-buffer x)
             (ivy--reset-state ivy-last))
           "kill")
          ("j"
           ivy--switch-buffer-other-window-action
           "other window")))))

  (use-package counsel-projectile
    :ensure t
    :config
    (counsel-projectile-on))

  (use-package ivy-hydra :ensure t)
#+END_SRC

From [[http://pragmaticemacs.com/emacs/dont-kill-buffer-kill-this-buffer-instead/][Pragmatic Emacs]] a more concise way to kill the buffer.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src

* Discover-ability

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (which-key-mode))
#+END_SRC
