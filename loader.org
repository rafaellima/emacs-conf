#+TITLE: My GNU Emacs configuration
#+STARTUP: indent
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction

This is my version of an configuration file for GNU Emacs. I have been using GNU Emacs since 2015 when I was introduced to it by a colleague.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Rafael Lima")
#+END_SRC


* A secure Emacs environment

Great article why [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Your editor is malware]]. The following basically sets up the configuration to adhere to the articles recommondations.

Fix MACOS certificate issue gnutils

#+BEGIN_SRC shell :exports none
python3 -m pip install --user certifi
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (setq tls-checktrust t)

  (setq python (or (executable-find "py.exe")
                   (executable-find "python3")
                   ))

  (let ((trustfile
         (replace-regexp-in-string
          "\\\\" "/"
          (replace-regexp-in-string
           "\n" ""
           (shell-command-to-string (concat python " -m certifi"))))))
    (setq tls-program
          (list
           (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                   (if (eq window-system 'w32) ".exe" "") trustfile)))
    (setq gnutls-verify-error t)
    (setq gnutls-trustfiles (list trustfile)))
#+END_SRC

* Installing use-package
** Setup

GNU Emacs has a lot of packages that make things very easy for the
user. The package management infrastructure makes it a breeze to
install new packages and keep up-to-date with their development.

There are several package archives available for GNU Emacs:

- GNU
- Marmalade
- Melpa

Each archive will write its files in a seperate archive directory.

#+BEGIN_SRC emacs-lisp
  (require 'package)
#+END_SRC

Because the default setting for package-archives is to use the HTTP access to the GNU archive, I set the variable to `nil` before adding the HTTPS variants.

#+name: credmp-package-infrastructure
#+begin_src emacs-lisp

  (defvar gnu '("gnu" . "https://elpa.gnu.org/packages/"))
  (defvar melpa '("melpa" . "https://melpa.org/packages/"))
  (defvar melpa-stable '("melpa-stable" . "https://stable.melpa.org/packages/"))

  ;; Add marmalade to package repos
  (setq package-archives nil)
  (add-to-list 'package-archives melpa-stable t)
  (add-to-list 'package-archives melpa t)
  (add-to-list 'package-archives gnu t)
#+end_src

Initialize the archive and refresh the contents in case there is no cached archive.

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (unless (and (file-exists-p (concat init-dir "elpa/archives/gnu"))
               (file-exists-p (concat init-dir "elpa/archives/melpa"))
               (file-exists-p (concat init-dir "elpa/archives/melpa-stable")))
    (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing
packages will be installed. The packages-install function deals with
this check and takes care of any loading of the packages.

#+name: credmp-package-installer
#+begin_src emacs-lisp
  (defun packages-install (&rest packages)
    (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (when (not (package-installed-p name))
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+end_src

** The package

#+name: credmp-package-installer
#+begin_src emacs-lisp
  ;; Install extensions if they're missing
  (defun init--install-packages ()
    (message "Lets install some packages")
    (packages-install
     ;; Since use-package this is the only entry here
     ;; ALWAYS try to use use-package!
     (cons 'use-package melpa)
     ))

  (condition-case nil
      (init--install-packages)
    (error
     (package-refresh-contents)
     (init--install-packages)))
#+end_src

* Installing try-package
** Setup
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC

* Installing initializer profiler
** setup
#+BEGIN_SRC emacs-lisp
  (use-package esup
    :ensure t)
#+END_SRC

* Metrics

Wakatime
#+begin_src emacs-lisp
  (use-package wakatime-mode
    :ensure t)

(global-wakatime-mode)
#+end_src

* Dashboard

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :config
  (dashboard-setup-startup-hook))
#+END_SRC

* Moving around

Disable tab

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Rotate - good for switching windows when purpose is not active

#+BEGIN_SRC emacs-lisp
  (use-package rotate
    :ensure t
    :bind (("C-c pw" . rotate-window)))
#+END_SRC

iedit - edit one occurance of some text in a buffer or region

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind (("C-c -;" . iedit-mode)))
#+END_SRC

Be sure to just ask for y/n instead of yes/no.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Bookmarks are very useful for quickly jumping around files.

#+BEGIN_SRC emacs-lisp
  (use-package bm
    :ensure t
    :bind (("C-c =" . bm-toggle)
           ("C-c [" . bm-previous)
           ("C-c ]" . bm-next)))

#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-x" . counsel-M-x)
     ("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

   (use-package swiper
     :pin melpa-stable
     :diminish ivy-mode
     :ensure t
     :bind*
     (("C-s" . swiper)
      ("C-c C-r" . ivy-resume)
      ("C-x C-f" . counsel-find-file)
      ("C-c h f" . counsel-describe-function)
      ("C-c h v" . counsel-describe-variable)
      ("C-c i u" . counsel-unicode-char)
      ("M-i" . counsel-imenu)
      ("C-c g" . counsel-git)
      ("C-c j" . counsel-git-grep)
      ("C-c k" . counsel-ag)
      ("C-c l" . scounsel-locate))
     :config
     (progn
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (define-key read-expression-map (kbd "C-r") #'counsel-expression-history)
       (ivy-set-actions
	'counsel-find-file
	'(("d" (lambda (x) (delete-file (expand-file-name x)))
           "delete"
           )))
       (ivy-set-actions
	'ivy-switch-buffer
	'(("k"
           (lambda (x)
             (kill-buffer x)
             (ivy--reset-state ivy-last))
           "kill")
          ("j"
           ivy--switch-buffer-other-window-action
           "other window")))))

(use-package counsel-projectile
  :ensure t
  :config
  (counsel-projectile-mode))

  (use-package ivy-hydra :ensure t)
#+END_SRC

Projectile settings

#+begin_src emacs-lisp
(projectile-global-mode)
(setq projectile-enable-caching t)
#+end_src

Counsel-projectile shortcuts

#+begin_src emacs-lisp
(global-set-key (kbd "C-c p f") 'counsel-projectile-find-file)
(global-set-key (kbd "C-c p d") 'counsel-projectile-find-dir)
(global-set-key (kbd "C-c p b") 'counsel-projectile-switch-buffer)
(global-set-key (kbd "C-c p s") 'projectile-grep)
(global-set-key (kbd "C-c p p") 'counsel-projectile-switch-project)
#+end_src

From [[http://pragmaticemacs.com/emacs/dont-kill-buffer-kill-this-buffer-instead/][Pragmatic Emacs]] a more concise way to kill the buffer.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src

* Discover-ability

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (which-key-mode))
#+END_SRC

* Environment

#+name: starter-kit-osX-workaround
#+begin_src emacs-lisp
  (if (or
       (eq system-type 'darwin)
       (eq system-type 'berkeley-unix))
      (setq system-name (car (split-string system-name "\\."))))

  (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
  (push "/usr/local/bin" exec-path)

  ;; /usr/libexec/java_home
  ;;(setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home")
#+end_src

** GUI

- Turn off mouse interface early in startup to avoid momentary display.

#+name: credmp-gui
#+begin_src emacs-lisp
  (menu-bar-mode 1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

- Turn off auto-save and backup

#+begin_src emacs-lisp
  (setq auto-save-default nil)
  (setq backup-inhibited t)
#+end_src

- Purpose

#+begin_src emacs-lisp
(use-package window-purpose
  :ensure t
  :config
  (purpose-mode))

(add-to-list 'purpose-user-mode-purposes '(ruby-mode . ru))
(add-to-list 'purpose-user-mode-purposes '(magit-mode . git))
(add-to-list 'purpose-user-mode-purposes '(org-mode . org))
(add-to-list 'purpose-user-mode-purposes '(rspec-mode . rspec))
(purpose-compile-user-configuration)
#+end_src


- Ace window
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t)

  (global-set-key (kbd "C-x o") 'ace-window)
#+end_src

* Look and feel
** all the icons

We need to run all-the-icons-install-fonts as well
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

** mode-line
*** Doom modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
      :ensure t
      :hook (after-init . doom-modeline-mode))
#+END_SRC
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (when window-system
    (scroll-bar-mode -1))
#+END_SRC

The default frame title isn't useful. This binds it to the name of the current
project:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Custom theme

Simple script to load desired theme on startup

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :config (load-theme 'doom-one-light t))
#+END_SRC

** Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Set default font and configure font resizing

I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+BEGIN_SRC emacs-lisp
  (setq hrs/default-font "Inconsolata")
  (setq hrs/default-font-size 18)
  (setq hrs/current-font-size hrs/default-font-size)

  (setq hrs/font-change-increment 1.1)

  (defun hrs/font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat hrs/default-font "-" (number-to-string hrs/current-font-size)))

  (defun hrs/set-font-size ()
    "Set the font to `hrs/default-font' at `hrs/current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (hrs/font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))

  (defun hrs/reset-font-size ()
    "Change font size back to `hrs/default-font-size'."
    (interactive)
    (setq hrs/current-font-size hrs/default-font-size)
    (hrs/set-font-size))

  (defun hrs/increase-font-size ()
    "Increase current font size by a factor of `hrs/font-change-increment'."
    (interactive)
    (setq hrs/current-font-size
          (ceiling (* hrs/current-font-size hrs/font-change-increment)))
    (hrs/set-font-size))

  (defun hrs/decrease-font-size ()
    "Decrease current font size by a factor of `hrs/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq hrs/current-font-size
          (max 1
               (floor (/ hrs/current-font-size hrs/font-change-increment))))
    (hrs/set-font-size))

  (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
  (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
  (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

  (hrs/reset-font-size)
#+END_SRC

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode))
#+END_SRC

** Hide certain modes from the modeline

I'd rather have only a few necessary mode identifiers on my modeline. This
either hides or "renames" a variety of major or minor modes using the =diminish=
package.

#+BEGIN_SRC emacs-lisp
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))

  (diminish-minor-mode 'abbrev 'abbrev-mode)
  (diminish-minor-mode 'simple 'auto-fill-function)
  (diminish-minor-mode 'company 'company-mode)
  (diminish-minor-mode 'flycheck 'flycheck-mode)
  (diminish-minor-mode 'flyspell 'flyspell-mode)
  (diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
  (diminish-minor-mode 'projectile 'projectile-mode)
  (diminish-minor-mode 'ruby-end 'ruby-end-mode)
  (diminish-minor-mode 'subword 'subword-mode)
  (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  (diminish-minor-mode 'yard-mode 'yard-mode)
  (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  (diminish-minor-mode 'wrap-region 'wrap-region-mode)

  (diminish-minor-mode 'paredit 'paredit-mode " π")

  (diminish-major-mode 'emacs-lisp-mode-hook "el")
  (diminish-major-mode 'haskell-mode-hook "λ=")
  (diminish-major-mode 'lisp-interaction-mode-hook "λ")
  (diminish-major-mode 'python-mode-hook "Py")
#+END_SRC


* Programming

** Elixir

#+begin_src emacs-lisp
  (use-package elixir-mode
    :ensure t)
  (use-package alchemist
    :ensure t)
#+end_src

Use smartparens to add `end` as soon as you finish to type in the `do` keyword

#+begin_src emacs-lisp
(require 'smartparens)

(defun my-elixir-do-end-close-action (id action context)
  (when (eq action 'insert)
    (newline-and-indent)
    (previous-line)
    (indent-according-to-mode)))

(sp-with-modes '(elixir-mode)
  (sp-local-pair "do" "end"
         :when '(("SPC" "RET"))
         :post-handlers '(:add my-elixir-do-end-close-action)
         :actions '(insert)))
#+end_src

** General programming

*** Look and feel

Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t)
#+END_SRC

Enable the prettify symbols mode. It will translate (fn) to the lambda
sign.

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC

*** Version Control
Magit is the only thing you need when it comes to Version Control (Git)

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-c m s" . magit-status)))

  (use-package magit-gitflow
    :ensure t
    :config
    (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
#+END_SRC

*** Xclip
use xclip to copy/paste in emacs-nox

#+begin_src emacs-lisp
(unless window-system
  (when (getenv "DISPLAY")
    (defun xclip-cut-function (text &optional push)
      (with-temp-buffer
	(insert text)
	(call-process-region (point-min) (point-max) "xclip" nil 0 nil "-i" "-selection" "clipboard")))
    (defun xclip-paste-function()
      (let ((xclip-output (shell-command-to-string "xclip -o -selection clipboard")))
	(unless (string= (car kill-ring) xclip-output)
	  xclip-output )))
    (setq interprogram-cut-function 'xclip-cut-function)
    (setq interprogram-paste-function 'xclip-paste-function)
    ))
#+end_src

** Ruby

I'm currently working a lot with Ruby (on Rails). Adding rinari + rspec_mode

#+begin_src emacs-lisp
(require 'rinari)
(require 'rspec-mode)

(setq ruby-insert-encoding-magic-comment nil)
#+end_src

**** Rbenv
Add rbenv conf. With this configuration all bundler commands will work from inside emacs

#+begin_src emacs-lisp
  (if (file-exists-p "/usr/local/bin/rbenv")
  (require 'rbenv)

  (setq rbenv-installation-dir "/usr/local/rbenv")

  (global-rbenv-mode))

  ;; Setting rbenv path
  (setenv "PATH" (concat (getenv "HOME") "/.rbenv/shims:" (getenv "HOME") "/.rbenv/bin:" (getenv "PATH")))
  (setq exec-path (cons (concat (getenv "HOME") "/.rbenv/shims") (cons (concat (getenv "HOME") "/.rbenv/bin") exec-path)))

#+end_src


**** Smartparens
Configuring smartparens for ruby

#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t)

(smartparens-global-mode)

  (sp-with-modes '(ruby-mode)
    (sp-local-pair "do" "end"
                 :when '(("SPC" "RET"))
                 :post-handlers '(sp-ruby-def-post-handler)
                 :actions '(insert navigate)))
#+end_src


**** Pry
In order to enable pry when using rspec-mode we need to initialize inf-ruby
To do so, use C-x C-q when you've hit a breakpoint

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'inf-ruby-switch-setup)
#+end_src

** Go

emacs-go-mode - https://arenzana.org/2019/01/emacs-go-mode/
tutorial -> http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/
another tutorial -> https://dominik.honnef.co/posts/2013/03/writing_go_in_emacs/

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t)
#+END_SRC

set GOPATH
#+BEGIN_SRC emacs-lisp
  ;;(setenv "GOPATH" "/Users/rafael/go")
(use-package exec-path-from-shell
  :ensure t
  :defer  2
  :config
  (dolist (var '("GOPATH"  "NVM_BIN"))
    (add-to-list 'exec-path-from-shell-variables var))
  (exec-path-from-shell-initialize))
#+END_SRC

Auto-complete
#+BEGIN_SRC emacs-lisp
  (use-package go-autocomplete
    :ensure t)

  (require 'go-autocomplete)
  (require 'auto-complete-config)
  (ac-config-default)
#+END_SRC

# Install github.com/sourcegraph/go-langserver

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t)

  (use-package lsp-mode
    :commands (lsp lsp-deferred))

  (add-hook 'go-mode-hook #'lsp-deferred)

  (setq-default
    tab-width 4
    standard-indent 4)

  (use-package company-lsp
    :commands company-lsp)
#+END_SRC

# go get golang.org/x/tools/cmd/goimports
#+BEGIN_SRC emacs-lisp
(setq gofmt-command "goimports")
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

flymake-mode go
#+BEGIN_SRC emacs-lisp
(use-package flymake-go
  :ensure t)
#+END_SRC

gotest
#+BEGIN_SRC emacs-lisp
(use-package gotest
  :ensure t)

(define-key go-mode-map (kbd "C-x f") 'go-test-current-file)
(define-key go-mode-map (kbd "C-x t") 'go-test-current-test)
(define-key go-mode-map (kbd "C-x p") 'go-test-current-project)
(define-key go-mode-map (kbd "C-x b") 'go-test-current-benchmark)
(define-key go-mode-map (kbd "C-x x") 'go-run)
#+END_SRC

** Web editing


The web-mode is particularily good for editing HTML and JS files.

#+name: credmp-package-web
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.xhtml?\\'" . web-mode))

    (defun my-web-mode-hook ()
      "Hooks for Web mode."
      (setq web-mode-enable-auto-closing t)
      (setq web-mode-enable-auto-quoting t)
      (setq web-mode-markup-indent-offset 2))

    (add-hook 'web-mode-hook  'my-web-mode-hook))

  (use-package less-css-mode
    :ensure t)

  (use-package emmet-mode
    :ensure t
    :config
    (add-hook 'clojure-mode-hook 'emmet-mode))
#+end_src

** Plugins
*** Ace jump
Help move the cursor within Emacs

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :ensure t
    :bind ("C-c s" . 'ace-jump-mode))
#+end_src

*** Flycheck

 #+begin_src emacs-lisp
 (use-package flycheck
  :ensure t)
 #+end_src

** Clojure

The clojure ecosystem for GNU Emacs consists out of CIDER and bunch of
supporting modules.

*** CIDER

#+name: credmp-clojure
#+begin_src emacs-lisp
  (use-package cider
    :ensure t
    :pin melpa-stable

    :config
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (add-hook 'cider-mode-hook #'cider-hydra-mode)
    (add-hook 'clojure-mode-hook #'paredit-mode)
    (setq cider-repl-use-pretty-printing t)
    (setq cider-repl-display-help-banner nil)
    (setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")

    :bind (("M-r" . cider-namespace-refresh)
           ("C-c r" . cider-repl-reset)
           ("C-c ." . cider-reset-test-run-tests))
    )

  (use-package clj-refactor
    :ensure t
    :config
    (add-hook 'clojure-mode-hook (lambda ()
                                   (clj-refactor-mode 1)
                                   ;; insert keybinding setup here
                                   ))
    (cljr-add-keybindings-with-prefix "C-c C-m")
    (setq cljr-warn-on-eval nil)
    :bind ("C-c '" . hydra-cljr-help-menu/body)
  )
#+end_src
**** TODO Cider Support Functions

Some support functions to help with the connection between the buffer
and the REPL. Big caveat you need to fix here is the hard-coded
cider-repl-reset, which should be project specific.

!TODO! fix this.

#+BEGIN_SRC emacs-lisp
  (defun cider-repl-command (cmd)
    "Execute commands on the cider repl"
    (cider-switch-to-repl-buffer)
    (goto-char (point-max))
    (insert cmd)
    (cider-repl-return)
    (cider-switch-to-last-clojure-buffer))

  (defun cider-repl-reset ()
    "Assumes reloaded + tools.namespace is used to reload everything"
    (interactive)
    (save-some-buffers)
    (cider-repl-command "(trivia.core/reset)"))

  (defun cider-reset-test-run-tests ()
    (interactive)
    (cider-repl-reset)
    (cider-test-run-project-tests))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq cider-cljs-lein-repl
	"(do (require 'figwheel-sidecar.repl-api)
         (figwheel-sidecar.repl-api/start-figwheel!)
         (figwheel-sidecar.repl-api/cljs-repl))")
#+END_SRC


*** LISP Editing

#+name: credmp-lisp-editing
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :diminish paredit-mode
    :config
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
    (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
    :bind (("C-c d" . paredit-forward-down))
    )

  ;; Ensure paredit is used EVERYWHERE!
  (use-package paredit-everywhere
    :ensure t
    :diminish paredit-everywhere-mode
    :config
    (add-hook 'prog-mode-hook #'paredit-everywhere-mode))

  (use-package highlight-parentheses
    :ensure t
    :diminish highlight-parentheses-mode
    :config
    (add-hook 'emacs-lisp-mode-hook
              (lambda()
                (highlight-parentheses-mode)
                )))

  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'lisp-mode-hook
              (lambda()
                (rainbow-delimiters-mode)
                )))

  (global-highlight-parentheses-mode)
#+END_SRC
** Groovy

Setting up groovy (mostly for Jenkins)

#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t)
#+end_src

#+begin_src emacs-lisp
  (use-package groovy-mode
     :mode ("\\.g\\(?:ant\\|roovy\\|radle\\)\\'" "Jenkinsfile")
     :init
     (setq groovy-indent-offset 2))
#+end_src

#+begin_src emacs-lisp
  (use-package jenkins
    :ensure t)
#+end_src

** Autocomplete mode

*** company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t)
#+END_SRC


** Restclient
#+BEGIN_SRC
  (use-package restclient
    :ensure t)
#+END_SRC
* Devops
** Terraform
#+begin_src emacs-lisp
(use-package terraform-mode
    :ensure t)
#+end_src

** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
    :ensure t)
#+end_src

* GTD
*** Org-mode

org-bullets-mode

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t)
#+END_SRC

Org-mode installation

#+BEGIN_SRC emacs_lisp
(use-package org-mode
  :ensure t
  :config (org-bullets-mode 1))
#+END_SRC

Add org-mode custom configuration

#+begin_src emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "IN PROGRESS(i)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)"))))

(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("IN PROGRESS" :foreground "blue" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold))))
#+end_src

#+BEGIN_SRC
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t)
   (ruby .)))
#+END_SRC
